<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>Vita: vita::symbol_factory Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Vita
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacevita.html">vita</a></li><li class="navelem"><a class="el" href="classvita_1_1symbol__factory.html">symbol_factory</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classvita_1_1symbol__factory-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">vita::symbol_factory Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>An abstract factory (the essence of the pattern is to provide an interface for creating families of related or dependent objects, i.e.  
 <a href="classvita_1_1symbol__factory.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a66772b29d42b71d92f7a78747313ae23"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvita_1_1symbol__factory.html#a66772b29d42b71d92f7a78747313ae23">args</a> (const std::string &amp;) const </td></tr>
<tr class="separator:a66772b29d42b71d92f7a78747313ae23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09dc8e4614f7af5e93d4eee27a53fa29"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classvita_1_1symbol.html">symbol</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvita_1_1symbol__factory.html#a09dc8e4614f7af5e93d4eee27a53fa29">make</a> (const std::string &amp;, <a class="el" href="namespacevita.html#ac33b6e76367210a9fc3b80e940ed41a8">cvect</a>=<a class="el" href="namespacevita.html#ac33b6e76367210a9fc3b80e940ed41a8">cvect</a>{0})</td></tr>
<tr class="separator:a09dc8e4614f7af5e93d4eee27a53fa29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8a658954050d3101f93b50f3ec33ee5"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classvita_1_1symbol.html">symbol</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvita_1_1symbol__factory.html#ac8a658954050d3101f93b50f3ec33ee5">make</a> (<a class="el" href="namespacevita.html#aa7b3178dc7b1402efb37f6596353042c">domain_t</a>, int, int, <a class="el" href="namespacevita.html#ab4bee4c13eaf6e5d61b4900cae4f0447">category_t</a>=0)</td></tr>
<tr class="separator:ac8a658954050d3101f93b50f3ec33ee5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d07ce7e7f6fe4ebcab02a16c614d8a2"><td class="memTemplParams" colspan="2">template&lt;class &gt; </td></tr>
<tr class="memitem:a5d07ce7e7f6fe4ebcab02a16c614d8a2"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classvita_1_1symbol__factory.html#a5d07ce7e7f6fe4ebcab02a16c614d8a2">register_symbol</a> (const std::string &amp;, unsigned)</td></tr>
<tr class="memdesc:a5d07ce7e7f6fe4ebcab02a16c614d8a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">registers a new symbol inside the factory  <a href="#a5d07ce7e7f6fe4ebcab02a16c614d8a2">More...</a><br /></td></tr>
<tr class="separator:a5d07ce7e7f6fe4ebcab02a16c614d8a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71759b113c10e415b69ba02e298eb450"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a71759b113c10e415b69ba02e298eb450"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvita_1_1symbol__factory.html#a71759b113c10e415b69ba02e298eb450">symbol_factory</a> ()</td></tr>
<tr class="memdesc:a71759b113c10e415b69ba02e298eb450"><td class="mdescLeft">&#160;</td><td class="mdescRight">The factory is preloaded with a number of common symbols. <br /></td></tr>
<tr class="separator:a71759b113c10e415b69ba02e298eb450"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a955d947896396dd505e92c91723beff4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvita_1_1symbol__factory.html#a955d947896396dd505e92c91723beff4">unregister_symbol</a> (const std::string &amp;)</td></tr>
<tr class="separator:a955d947896396dd505e92c91723beff4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>An abstract factory (the essence of the pattern is to provide an interface for creating families of related or dependent objects, i.e. </p>
<p>symbols, without specifying ther concrete classes, e.g. numbers, functions...).</p>
<p>The factory determines the actual concrete type of the symbol to be created and it's here that the object is actually created. However, the factory only returns an abstract pointer to the created concrete object.</p>
<p>This insulates client code from object creation by having clients ask a factory object to create an object of the desired abstract type and to return an abstract pointer to the object. </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="example3_8cc-example.html#_a3">example3.cc</a>, <a class="el" href="example4_8cc-example.html#_a3">example4.cc</a>, <a class="el" href="example5_8cc-example.html#_a3">example5.cc</a>, and <a class="el" href="example6_8cc-example.html#_a11">example6.cc</a>.</dd>
</dl>
<p>Definition at line <a class="el" href="factory_8h_source.html#l00036">36</a> of file <a class="el" href="factory_8h_source.html">factory.h</a>.</p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a66772b29d42b71d92f7a78747313ae23"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned vita::symbol_factory::args </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>name of the symbol (case sensitive). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of distinct categories needed to build the symbol. </dd></dl>

<p>Definition at line <a class="el" href="factory_8cc_source.html#l00181">181</a> of file <a class="el" href="factory_8cc_source.html">factory.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a09dc8e4614f7af5e93d4eee27a53fa29"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classvita_1_1symbol.html">symbol</a> &gt; vita::symbol_factory::make </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacevita.html#ac33b6e76367210a9fc3b80e940ed41a8">cvect</a>&#160;</td>
          <td class="paramname"><em>c</em> = <code><a class="el" href="namespacevita.html#ac33b6e76367210a9fc3b80e940ed41a8">cvect</a>{0}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>name of the symbol to be created (case sensitive). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>a list of categories used by the the symbol constructor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an abstract pointer to the created symbol.</dd></dl>
<p>As the factory only returns an abstract pointer, the client code (which requests the object from the factory) does not know - and is not burdened by - the actual concrete type of the object which was just created. However, the type of the concrete object is known by the abstract factory via the <code>name</code> and <code>c</code> arguments.</p>
<dl class="section attention"><dt>Attention</dt><dd>If <code>name</code> is not recognized as a preregistered symbol, it's registered on the fly as a constant.</dd></dl>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>The client code has no knowledge whatsoever of the concrete type, not needing to include any header files or class declarations relating to the concrete type. The client code deals only with the abstract type. Objects of a concrete type are indeed created by the factory, but the client code accesses such objects only through their abstract interface.</li>
<li>Adding new concrete types is done by modifying the client code to use a different factory, a modification which is typically one line in one file (the different factory then creates objects of a different concrete type, but still returns a pointer of the same abstract type as before - thus insulating the client code from change). This is significantly easier than modifying the client code to instantiate a new type, which would require changing every location in the code where a new object is created (as well as making sure that all such code locations also have knowledge of the new concrete type, by including for instance a concrete class header file). Since all factory objects are stored globally in a singleton object and all client code goes through the singleton to access the proper factory for object creation, changing factories is as easy as changing the singleton object. </li>
</ul>
</dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="example3_8cc-example.html#a5">example3.cc</a>, <a class="el" href="example4_8cc-example.html#a5">example4.cc</a>, <a class="el" href="example5_8cc-example.html#a5">example5.cc</a>, and <a class="el" href="example6_8cc-example.html#a13">example6.cc</a>.</dd>
</dl>
<p>Definition at line <a class="el" href="factory_8cc_source.html#l00119">119</a> of file <a class="el" href="factory_8cc_source.html">factory.cc</a>.</p>

</div>
</div>
<a class="anchor" id="ac8a658954050d3101f93b50f3ec33ee5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classvita_1_1symbol.html">symbol</a> &gt; vita::symbol_factory::make </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacevita.html#aa7b3178dc7b1402efb37f6596353042c">domain_t</a>&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacevita.html#ab4bee4c13eaf6e5d61b4900cae4f0447">category_t</a>&#160;</td>
          <td class="paramname"><em>c</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">d</td><td>domain of the symbol. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">min</td><td>lower bound for the number value. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max</td><td>upper bound for the number value. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>a category used by the symbol constructor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an abstract pointer to the created symbol.</dd></dl>
<p>This is an alternative way to build a number. The other <code>make</code> method finds the domain of the number checking the input string's format.</p>
<p>Here there're explicit parameters for domain / category and we can also specify a range (<code>[min; max]</code>). </p>

<p>Definition at line <a class="el" href="factory_8cc_source.html#l00161">161</a> of file <a class="el" href="factory_8cc_source.html">factory.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a5d07ce7e7f6fe4ebcab02a16c614d8a2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool vita::symbol_factory::register_symbol </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>registers a new symbol inside the factory </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>name of the symbol to be registered (case sensitive). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>number of arguments for the constructor of the symbol. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the symbol <code>T</code> has been added to the factory.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd><code>name</code> is a key: the function doesn't register different symbols with the same name. </dd></dl>

<p>Definition at line <a class="el" href="factory_8h_source.html#l00076">76</a> of file <a class="el" href="factory_8h_source.html">factory.h</a>.</p>

</div>
</div>
<a class="anchor" id="a955d947896396dd505e92c91723beff4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vita::symbol_factory::unregister_symbol </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>name of the symbol (case sensitive). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the symbol has been unregistered.</dd></dl>
<p>Unregister the symbol from the factory. </p><dl class="section note"><dt>Note</dt><dd>constants and variable aren't registered in the factory, so they cannot be unregistered. </dd></dl>

<p>Definition at line <a class="el" href="factory_8cc_source.html#l00196">196</a> of file <a class="el" href="factory_8cc_source.html">factory.cc</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="factory_8h_source.html">factory.h</a></li>
<li><a class="el" href="factory_8cc_source.html">factory.cc</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sat May 27 2017 16:33:09 for Vita by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.9.1
</small></address>
</body>
</html>
